지금까지 정말 숨 가쁘게 달려오셨습니다\! 설치부터 시작해서 **테이블 생성, 데이터 입력, 조회, 조인, 그리고 서브쿼리**까지, 데이터 분석가가 실무에서 쓰는 핵심 기능의 80%를 이미 경험하셨습니다.

나중에 까먹었을 때 이 부분만 봐도 기억이 나도록 깔끔하게 요약해 드릴게요.

-----

### 1\. 뼈대 만들기 (DDL: 구조 정의)

엑셀 파일을 만들고 시트를 만드는 과정입니다.

  * **데이터베이스 생성:** `CREATE DATABASE 이름;` (폴더 만들기)
  * **사용 선언:** `USE 이름;` (폴더 더블클릭해서 들어가기)
  * **테이블 생성:** `CREATE TABLE 이름 ( ... );` (엑셀 시트 만들기)
      * `INT`: 숫자
      * `VARCHAR(n)`: 문자 (n글자까지)
      * `DATE`: 날짜
      * `PRIMARY KEY`: 고유 번호 (주민번호 같은 것)
      * `AUTO_INCREMENT`: 번호 자동 증가

### 2\. 데이터 다루기 (DML: 데이터 조작)

만들어진 시트에 값을 채우거나 고치는 과정입니다.

  * **입력:** `INSERT INTO 테이블 (컬럼1, 컬럼2) VALUES (값1, 값2);`
  * **수정:** `UPDATE 테이블 SET 컬럼 = 변경할값 WHERE 조건;` (조건 없으면 다 바뀜 주의\!)
  * **삭제:** `DELETE FROM 테이블 WHERE 조건;` (조건 없으면 다 지워짐 주의\!)

-----

### 3\. 데이터 분석하기 (DQL: 데이터 조회) **★가장 중요★**

현업에서 제일 많이 쓰는 "데이터 뽑아주세요" 명령어들입니다.

#### 기본 조회

  * **가져오기:** `SELECT 컬럼명`
  * **어디서:** `FROM 테이블명`
  * **조건필터:** `WHERE 조건` (예: `age >= 20`)

#### 집계와 그룹화 (피벗 테이블)

  * **그룹짓기:** `GROUP BY 컬럼명` (이 컬럼을 기준으로 뭉쳐라)
  * **계산함수:**
      * `COUNT(*)`: 개수 세기
      * `SUM(컬럼)`: 합계 구하기
      * `AVG(컬럼)`: 평균 구하기
      * `MAX(컬럼)` / `MIN(컬럼)`: 최대/최소값

#### 테이블 합치기 (VLOOKUP)

  * **조인:** `JOIN 붙일테이블 ON 기준테이블.키 = 붙일테이블.키`
      * 예: `JOIN member m ON o.member_id = m.id` (주문표의 회원ID와 회원표의 ID가 같은 것끼리 붙여라)

-----

### 4\. 고급 분석 기술 (프로의 영역)

단순 조회를 넘어, 데이터를 가공하고 비즈니스 인사이트를 만드는 기술입니다.

#### 조건별 분류 (IF문)

데이터를 내가 원하는 등급이나 이름으로 바꿀 때 씁니다.

```sql
CASE
    WHEN 조건1 THEN '결과1'
    WHEN 조건2 THEN '결과2'
    ELSE '나머지'
END
```

#### 서브쿼리 (쿼리 속의 쿼리)

복잡한 계산 결과를 **마치 새로운 테이블인 것처럼** 재사용할 때 씁니다.

```sql
SELECT ...
FROM (
    SELECT ... FROM ...  -- [안쪽 쿼리] 1차 가공
) AS 별명                -- [중요] 반드시 별명(Alias)을 붙여야 함!
```

-----

### 💡 한 눈에 보는 "마스터 쿼리"

이 코드 하나에 우리가 배운 모든 문법이 녹아있습니다. 복사해서 저장해두세요\!

```sql
SELECT
    -- 4. 최종적으로 보여줄 컬럼 선택 및 가공 (CASE WHEN)
    이름,
    구매횟수,
    CASE
        WHEN 총금액 > 100000 THEN 'VIP'
        ELSE '일반'
    END AS 등급
FROM
    (
        -- 1. [서브쿼리] 데이터를 먼저 요약 (GROUP BY & 함수)
        SELECT
            m.name AS 이름,
            COUNT(o.id) AS 구매횟수,
            SUM(o.amount) AS 총금액
        -- 2. [JOIN] 흩어진 데이터를 합치기
        FROM orders o
        JOIN member m ON o.member_id = m.id
        -- 3. [WHERE] 필요한 데이터만 1차 필터링 (예: 2024년 데이터만)
        WHERE o.order_date >= '2024-01-01'
        GROUP BY m.name
    ) AS summary_table; -- 서브쿼리 별명 필수
```

이제 기초 문법은 완벽하게 떼셨습니다. 이 문법들을 조합하면 현업의 웬만한 데이터 요청은 다 처리할 수 있습니다.

**다음 단계로는 무엇을 하고 싶으신가요?**

1.  **"이탈 고객(CHURN) 데이터만 엑셀로 뽑기"** (실무에서 제일 많이 하는 '데이터 추출' 마무리)
2.  **"날짜 다루기 심화"** (매출 분석할 때 필수인 '월별/요일별 매출' 뽑기)
3.  **"SQL 문제 풀이"** (코딩 테스트 준비를 위해 해커랭크 같은 사이트 문제 풀어보기)

원하시는 방향을 말씀해 주시면 맞춰서 가이드해 드릴게요\!

오늘 학습하시면서 헷갈려하셨던 핵심 포인트와 에러 해결법을 **Markdown(MD)** 파일 형식으로 깔끔하게 정리해 드립니다.

복습하실 때 이 내용만 훑어보셔도 큰 도움이 될 거예요\!

-----

# 📌 SQL 초보 탈출: 헷갈리는 문법 & 에러 노트

## 1\. 쿼리 시작 전 필수 체크 (`USE`)

**에러 코드:** `Error Code: 1046. No database selected`

  * **상황:** 코드를 실행했는데 "어느 폴더(DB)를 쓸 건지 말을 안 해줬어\!"라고 컴퓨터가 멈춤.
  * **해결:** 무조건 쿼리 **맨 첫 줄**에 아래 코드를 박아두고 시작할 것.

<!-- end list -->

```sql
USE shop; -- 데이터베이스 이름
```

-----

## 2\. FROM과 JOIN의 관계

**궁금증:** "왜 `FROM users`를 안 썼는데 `u.nickname`을 쓸 수 있나요?"

  * **핵심:** `JOIN`은 `FROM`의 친구입니다. `JOIN`으로 붙이는 순간 이미 가져온 것과 같습니다.
  * **문법 공식:**
    ```sql
    FROM payments p          -- 1. 메인 테이블 가져오고 (이름: p)
    JOIN users u             -- 2. 서브 테이블 붙이고 (이름: u)
    ON p.user_id = u.user_id -- 3. 연결 고리 확인 (Key 매칭)
    ```
    👉 **결론:** 위 3줄이 실행되면 `p`와 `u` 모두 내 마음대로 꺼내 쓸 수 있다.

-----

## 3\. GROUP BY 필수 규칙

**에러 코드:** `Error Code: 1140 ... incompatible with sql_mode=only_full_group_by`

  * **상황:** 집계 함수(`SUM`, `MAX`, `COUNT`)를 썼는데, 기준이 되는 컬럼을 그룹으로 안 묶었을 때 발생.

  * **해결 공식:** `SELECT`에 있는 컬럼 중 **계산 함수가 안 씌워진 애들**은 무조건 `GROUP BY`에 적어야 한다.

    ```sql
    SELECT 
        nickname,       -- (A) 계산 안 함 (그냥 출력)
        SUM(amount)     -- (B) 계산 함
    FROM ...
    GROUP BY nickname;  -- (A)는 반드시 여기에 적어줘야 함!
    ```

-----

## 4\. 세미콜론(`;`)의 위치

**에러 상황:** `JOIN` 뒤에 `;`를 찍어서 `GROUP BY`가 실행 안 됨.

  * **핵심:** 세미콜론은 \*\*"문장의 마침표"\*\*다. 문장이 다 끝나기 전에는 찍지 말자.
      * ❌ `JOIN users u;` (여기서 끊으면 뒤에 GROUP BY는 낙동강 오리알)
      * ⭕ `GROUP BY u.nickname;` (진짜 맨 마지막에 쾅\!)

-----

## 5\. 코딩 순서 (작성 vs 실행)

SQL은 읽는 순서와 쓰는 순서가 정반대입니다. **안에서 밖으로(Inside-Out)** 작성하세요.

1.  **FROM / JOIN**: 재료(테이블) 찾기
2.  **WHERE / GROUP BY**: 재료 다듬기 (필터링, 뭉치기)
3.  **SELECT**: 접시에 담기 (컬럼 선택)
4.  **ORDER BY**: 예쁘게 플레이팅 (정렬) - *오늘 안 썼지만 참고\!*

-----

## 6\. 서브쿼리(Subquery) 작성법

**문법:** 쿼리 결과를 **가상의 테이블**처럼 만들어서 재사용할 때.

  * **필수:** 괄호 `()`로 감싸고, 반드시 뒤에 \*\*별명(`AS 이름`)\*\*을 붙여야 한다.

    ```sql
    FROM 
        (
            SELECT ...
        ) AS game_data;  -- <-- 이 별명이 없으면 에러(Error 1248) 남!
    ```

-----

## 💡 Tip: 전체 조회 vs 특정 조회

  * `SELECT *`: **"몽땅 다 보여줘."** (연습할 때 좋음)
  * `SELECT col1, col2`: **"이것만 딱 집어서 보여줘."** (실무에서 좋음, 속도 빠름)
  
네, 아주 좋은 질문입니다\! `Day5_SQL_Practice.ipynb` 파일에 복사해서 바로 실행해 볼 수 있도록 **단계별 예시 코드**를 준비했습니다.

이 코드를 실행하면서 \*\*"어느 시점에 데이터가 걸러지는지"\*\*를 느끼는 게 포인트입니다.

-----

### **1. `WHERE`만 쓰는 경우 (데이터 전처리)**

  * **상황:** "그룹이고 뭐고 다 필요 없고, 일단 **'전자제품'** 산 기록만 보여줘."
  * **특징:** 집계(SUM, COUNT) 하기 **전**에 원본 데이터에서 걸러냅니다.

<!-- end list -->

```python
# 1. WHERE 예시: '전자제품' 카테고리만 골라내기
sql_where = """
SELECT user_id, category, amount
FROM orders
WHERE category = '전자제품'
"""
print("--- [1] WHERE 결과 (전자제품만) ---")
print(pd.read_sql(sql_where, conn))
```

### **2. `GROUP BY`만 쓰는 경우 (단순 집계)**

  * **상황:** "고객(`user_id`)별로 총 얼마를 썼는지(`SUM`) 보고 싶어."
  * **특징:** 데이터를 사람별로 뭉쳐서 계산합니다.

<!-- end list -->

```python
# 2. GROUP BY 예시: 고객별 총 주문 금액
sql_groupby = """
SELECT user_id, SUM(amount) as total_spent
FROM orders
GROUP BY user_id
"""
print("\n--- [2] GROUP BY 결과 (고객별 합계) ---")
print(pd.read_sql(sql_groupby, conn))
```

### **3. `GROUP BY` + `HAVING` (미션 정답\! 🎯)**

  * **상황:** "고객별 합계를 구했는데, 그중에서 **총액이 5만 원 이상**인 큰손들만 남겨줘."
  * **특징:** `SUM(amount)` 값은 그룹화가 끝나야 알 수 있죠? 그래서 `WHERE`가 아니라 `HAVING`을 씁니다.

<!-- end list -->

```python
# 3. GROUP BY + HAVING 예시 (미션 정답)
sql_having = """
SELECT user_id, SUM(amount) as total_spent
FROM orders
GROUP BY user_id
HAVING SUM(amount) >= 50000
"""
print("\n--- [3] 미션 정답: 5만원 이상 구매 고객 ---")
print(pd.read_sql(sql_having, conn))
```

-----

### **💡 한눈에 보는 요약**

| 구분 | 영어 뜻 | 역할 | 시점 |
| :--- | :--- | :--- | :--- |
| **WHERE** | 어디에 있는? | **원본 데이터**를 거른다. | 묶기 전 (Before) |
| **GROUP BY**| \~에 의해 묶다 | 데이터를 **끼리끼리** 뭉친다. | 중간 (Process) |
| **HAVING** | \~를 가지고 있는 | **계산된 결과**를 거른다. | 묶은 후 (After) |

네, 정말 핵심을 꿰뚫는 질문입니다\! 이 두 가지 질문은 데이터 분석가 면접 단골 질문이기도 합니다.

아주 명쾌하게 정리해 드릴게요.

-----

### **1. WHERE vs HAVING: "검문소가 어디에 있는가?"**

둘 다 \*\*"조건을 걸어 데이터를 거르는 역할"\*\*을 하지만, \*\*거르는 시점(Timing)\*\*이 완전히 다릅니다.

  * **`WHERE` (1차 검문소 - 입장 컷)**

      * **시점:** 그룹으로 묶기 **전(Before)**.
      * **대상:** 원본 데이터 한 줄 한 줄(Row)을 검사합니다.
      * **예시:** "전자제품인 주문만 들어와\!", "2024년 데이터만 들어와\!"
      * **특징:** 아직 그룹이 안 만들어졌기 때문에 `SUM()`, `COUNT()` 같은 집계 함수를 **절대 쓸 수 없습니다.**

  * **`HAVING` (2차 검문소 - 결산 컷)**

      * **시점:** 그룹으로 묶고 계산을 마친 **후(After)**.
      * **대상:** 요약된 그룹 결과(Group)를 검사합니다.
      * **예시:** "다 합쳐서(SUM) 5만 원 넘는 팀만 남와\!", "평균 점수(AVG) 80점 이상인 반만 남아\!"
      * **특징:** `GROUP BY`가 없으면 거의 쓰지 않으며, **반드시 집계 함수와 함께** 놉니다.

> **한 줄 요약:**
>
>   * **원시 데이터**를 거를 땐 👉 `WHERE`
>   * \*\*계산된 결과(집계)\*\*를 거를 땐 👉 `HAVING`

-----

### **2. SQL `GROUP BY` vs 파이썬 `groupby()`**

네, **100% 같은 개념**으로 보셔도 됩니다\!
데이터 분석의 대원칙인 **"Split-Apply-Combine (나누고-적용하고-합치기)"** 전략을 사용합니다.

다만, **사용하는 문법 스타일**만 살짝 다릅니다. 비교해서 보여드릴게요.

#### **상황: "user\_id 별로 amount 합계를 구하라"**

**[SQL]**

  * SQL은 문장 안에서 "묶어라(`GROUP BY`)"라고 시키고, 윗줄(`SELECT`)에서 바로 계산 결과를 보여줍니다.

<!-- end list -->

```sql
SELECT user_id, SUM(amount)
FROM orders
GROUP BY user_id;
```

**[Python Pandas]**

  * 판다스는 일단 묶어둔 \*\*객체(덩어리)\*\*를 먼저 만들고, 그 뒤에 계산 메서드(`.sum()`)를 붙입니다.

<!-- end list -->

```python
# df가 데이터프레임이라고 할 때
df.groupby('user_id')['amount'].sum()
```

**차이점:**

  * **SQL:** 결과표를 바로 뱉어냅니다.
  * **Python:** `groupby()`만 하면 결과를 안 보여주고 `<pandas...Groupby object>`라는 껍데기만 나옵니다. 뒤에 반드시 `.sum()`, `.mean()` 등을 붙여야 결과를 보여줍니다.

-----

### **🎓 Day 5 졸업 시험 (마지막)**

개념이 정리되셨다면, 이 쿼리의 **실행 순서**를 맞춰보세요. (마음속으로 순서를 매겨보세요.)

```sql
SELECT user_id, SUM(amount)      -- (4) 보여준다
FROM orders                      -- (1) 가져온다
WHERE category = '의류'          -- (2) 1차로 거른다 (누구만?)
GROUP BY user_id                 -- (3) 묶는다
HAVING SUM(amount) >= 30000;     -- (4) 2차로 거른다 (계산 후)
```

**정답 순서:**
**FROM** (테이블 가져오기) ➡️ **WHERE** (의류만 남기기) ➡️ **GROUP BY** (고객별로 묶기) ➡️ **HAVING** (합계 3만 원 이상만 남기기) ➡️ **SELECT** (최종 결과 출력)

이 순서가 머릿속에 그려지신다면, 오늘 **GROUP BY**는 완벽하게 마스터하신 겁니다\!

좋습니다\! 물 들어올 때 노 저어야죠. 🚣‍♀️
JOIN은 처음엔 헷갈리지만, 원리 하나만 딱 잡으면 \*\*"엑셀의 VLOOKUP 상위 호환"\*\*이라는 걸 깨닫게 됩니다.

오늘 **JOIN**의 개념을 아주 직관적으로, 절대 잊어버리지 않게 설명해 드릴게요.

-----

### **Day 6: 테이블 붙이기 (JOIN)**

#### **1. 왜 쪼개 놓고 다시 붙일까?**

데이터베이스는 효율성을 위해 정보를 쪼개서 저장합니다.

  * **`orders` 테이블:** 주문 내역만 있음 (누가, 얼마 썼나)
  * **`users` 테이블:** 회원 정보만 있음 (이름, 나이, 사는 곳)

**문제:** 사장님이 \*\*"30대 서울 사는 회원들이 주문한 총액을 뽑아봐"\*\*라고 합니다.

  * `orders`에는 나이/주소가 없고,
  * `users`에는 주문 금액이 없습니다.

**해결:** 두 테이블을 \*\*`user_id` (공통된 열쇠)\*\*를 기준으로 **옆으로 딱 붙이는 것**, 그게 바로 **JOIN**입니다.

-----

### **2. 핵심 이미지: 다이어그램으로 이해하기**

가장 많이 쓰는 \*\*두 가지(INNER, LEFT)\*\*만 기억하면 됩니다.

[Image of SQL Joins Venn Diagram]

#### **① INNER JOIN (깐깐한 친구)**

  * **비유:** "소개팅"
  * **원리:** 양쪽 테이블에 \*\*모두 존재하는 데이터(교집합)\*\*만 남깁니다.
  * **상황:** "회원 가입도 했고(`users`), 주문도 한(`orders`) 사람만 보여줘."
  * **결과:** 주문 안 한 회원은 사라짐. 회원 정보 없는 비회원 주문도 사라짐.

#### **② LEFT JOIN (너그러운 친구) ⭐ *가장 중요***

  * **비유:** "부록(Appendix)"
  * **원리:** **왼쪽(기준) 테이블은 무조건 다 보여주고**, 오른쪽 테이블에 정보가 있으면 붙이고 없으면 비워둠(`NULL`).
  * **상황:** "**모든 회원(`users`) 명단을 뽑고**, 만약 주문 내역(`orders`)이 있으면 옆에 붙여줘. 주문 안 했으면 '비어있음'으로 표시해."
  * **결과:** 주문 안 한 회원도 리스트에 살아남음. (매출 분석할 때 '구매율' 구할 때 필수\!)

-----

### **3. 문법 공식 (암기하세요\!)**

```sql
SELECT *
FROM 테이블A (왼쪽: 기준)
________ JOIN 테이블B (오른쪽: 붙일 것)
ON 테이블A.열쇠 = 테이블B.열쇠;  -- 접착제 역할
```

  * **`ON`**: 두 테이블을 무엇으로 연결할지 정해주는 **접착제**입니다. (보통 ID 값)

-----

아주 날카로운 질문입니다\! ⚔️
지금 질문하신 내용은 \*\*"SQL이 모호함(Ambiguity)을 어떻게 처리하는가?"\*\*에 대한 핵심적인 부분입니다. 하나씩 명쾌하게 해결해 드릴게요.

-----

### **1. 평균값만 따로 출력이 가능한가요?**

**네, 당연합니다\!**
SQL에서는 보고 싶은 것만 `SELECT`에 적으면 됩니다. 다른 컬럼 없이 집계 함수(`AVG`, `SUM` 등)만 적으면, 딱 숫자 하나만(1행 1열) 결과로 나옵니다.

```python
# 평균값만 딱 하나 뽑아보기
sql_avg = "SELECT AVG(amount) FROM orders"
print(pd.read_sql(sql_avg, conn))
```

**결과:**

```
   AVG(amount)
0  23571.428571
```

이렇게 숫자 덩어리 하나가 나오기 때문에, 아까처럼 `WHERE amount > (...)` 괄호 안에 쏙 집어넣어서 비교할 수 있었던 것입니다.

-----

### **2. JOIN 했을 때, `user_id` 같은 키는 점(.) 없이 그냥 써도 되나요?**

**결론부터 말씀드리면: ❌ 절대 안 됩니다\! (에러 납니다)**

`JOIN`을 하면 두 테이블이 합쳐지죠? 이때 **양쪽 테이블에 똑같은 이름의 컬럼(`user_id`)이 있다면**, SQL은 \*\*"누구네 `user_id`를 말하는 거야?"\*\*라며 헷갈려합니다.

이걸 **"Ambiguous column name (모호한 컬럼 이름)"** 에러라고 합니다.

#### **규칙 정리 (이것만 기억하세요\!)**

1.  **양쪽에 다 있는 이름 (`user_id`):**

      * 반드시 \*\*`테이블이름.컬럼명`\*\*으로 소속을 밝혀야 합니다.
      * `users.user_id` 혹은 `orders.user_id` (둘 중 아무거나 써도 값은 같지만, 꼭 명시해야 함)

2.  **한쪽에만 있는 이름 (`name`, `amount`):**

      * 점(.) 없이 **그냥 써도 됩니다.** (`name`, `amount`)
      * 하지만, **`users.name`**, **`orders.amount`** 처럼 적어주는 것이 **가독성**에도 좋고 나중에 헷갈리지 않아서 더 추천합니다.

-----

### **🔍 코드로 비교 (O vs X)**

#### **(X) 에러 나는 코드**

```sql
SELECT user_id, name, amount  -- 🚨 에러! user_id가 어느 테이블 건지 모름
FROM users
INNER JOIN orders ON users.user_id = orders.user_id
```

> **Error:** `ambiguous column name: user_id`

#### **(O) 올바른 코드**

```sql
SELECT users.user_id, name, amount  -- ✅ users 테이블의 user_id라고 명시함
-- 또는 orders.user_id 라고 써도 됨 (JOIN 했으니 값은 같음)
FROM users
INNER JOIN orders ON users.user_id = orders.user_id
```

### **💡 꿀팁: 별칭(Alias) 쓰기**

테이블 이름이 길면 매번 `users.user_id` 치기 귀찮죠? 이럴 때 **별명**을 씁니다.

```sql
SELECT u.user_id, u.name, o.amount   -- u, o 로 짧게 줄여 씀
FROM users as u                      -- users를 이제부터 'u'라고 부르겠다
INNER JOIN orders as o               -- orders를 이제부터 'o'라고 부르겠다
ON u.user_id = o.user_id
```

실무에서는 이렇게 \*\*별칭(u, o)\*\*을 써서 `u.user_id`처럼 사용하는 게 국룰(표준)입니다\!

이해되셨나요? 겹치는 이름엔 **"반드시 소속(점)을 찍어준다\!"** 이것만 기억하시면 됩니다. 👌

네, **`WITH`** 구문은 SQL을 "초보"에서 "중수"로 끌어올려 주는 가장 중요한 문법 중 하나입니다.

정식 명칭은 \*\*CTE (Common Table Expression, 공통 테이블 표현식)\*\*라고 하는데, 이름이 어렵죠?
그냥 **"이름표 붙이기"** 또는 파이썬의 \*\*"변수 만들기"\*\*라고 생각하시면 완벽합니다.

-----

### **1. `WITH`가 왜 필요한가요?**

사용자님은 이미 파이썬을 하시니까, 파이썬으로 비유해 드릴게요.

#### **(1) 서브쿼리 방식 (우리가 지금까지 했던 것)**

마치 변수를 안 만들고 한 줄에 수식을 다 때려 넣는 것과 같습니다.

```python
# 읽기 어렵고 복잡함
print((100 * 20) + (50 / 2) - (10 * 3))
```

SQL에서는 `FROM (SELECT ... FROM (SELECT ...))` 처럼 괄호가 계속 겹쳐서 \*\*"인셉션"\*\*이 일어납니다. 해석하려면 괄호 제일 안쪽부터 찾아 들어가야 하죠.

#### **(2) `WITH` 방식 (세련된 방식)**

중간 계산 결과에 \*\*이름(변수)\*\*을 붙여서 정리하는 겁니다.

```python
# 파이썬 스타일
A_값 = 100 * 20
B_값 = 50 / 2
print(A_값 + B_값)
```

SQL에서도 복잡한 쿼리에 `RFM_SCORES`라는 이름을 붙여주고, 나중에 그 이름을 불러다 쓰는 겁니다.

-----

### **2. 문법 해부도**

구조는 아주 단순합니다. \*\*"정의하기"\*\*와 **"사용하기"** 두 단계입니다.

```sql
-- [1단계] 정의하기: "이제부터 이 쿼리 결과를 '임시_테이블'이라고 부를게!"
WITH 임시_테이블 AS (
    SELECT ...
    FROM ...
    WHERE ...
)

-- [2단계] 사용하기: "아까 만든 '임시_테이블' 가져와서 보여줘."
SELECT *
FROM 임시_테이블
WHERE ...
```

-----

### **3. 직접 비교: 서브쿼리 vs WITH**

아까 우리가 짠 코드를 비교해 보면 확 체감이 됩니다.

#### **Case A: 서브쿼리 (Subquery) - 괄호 지옥**

  * **특징:** `FROM` 안에 쿼리가 들어가고, 해석하려면 **안쪽부터** 봐야 합니다.

<!-- end list -->

```sql
SELECT user_id, ...
FROM (  -- 2. 여기서부터 계산 시작
    SELECT user_id, ...
    FROM orders
    GROUP BY user_id
)       -- 1. 여기까지 먼저 해석해야 함
WHERE ...
```

#### **Case B: WITH 절 (CTE) - 스토리텔링**

  * **특징:** 위에서 아래로 물 흐르듯 읽힙니다. (사람에게 친화적)

<!-- end list -->

```sql
-- 1. 먼저 이걸 계산해서 'SUMMARY'라고 부르자.
WITH SUMMARY AS (
    SELECT user_id, ... FROM orders GROUP BY user_id
)

-- 2. 자, 이제 'SUMMARY'를 가져와서 보여줘.
SELECT * FROM SUMMARY WHERE ...
```

-----

### **4. `WITH`를 쓰면 좋은 점 3가지**

1.  **가독성 (Readability):**
      * 코드가 길어져도 "아, 위에서 만든 `SUMMARY` 테이블을 가져다 썼구나" 하고 바로 이해할 수 있습니다.
2.  **재사용성 (Reusability):**
      * 이게 진짜 강력합니다. `WITH`로 한 번 만들어둔 테이블은 밑에서 **두 번, 세 번 계속 불러쓸 수 있습니다.** (서브쿼리는 필요할 때마다 코드를 복사 붙여넣기 해야 함)
3.  **임시성 (Temporary):**
      * `CREATE TABLE`처럼 데이터베이스에 영구적으로 저장되는 게 아닙니다. 이 쿼리가 실행되는 **0.1초 동안만 메모리에 잠깐 살았다가 사라집니다.** 그래서 부담 없이 막 만들어도 됩니다.

-----

### **5. 요약**

> **`WITH`는 복잡한 쿼리에 "임시 이름표"를 붙여주는 것이다.**

  * `WITH 별명 AS ( 복잡한 쿼리 )`
  * `SELECT * FROM 별명`

이제 코드를 보실 때 `WITH`가 나오면 겁먹지 마시고, **"아, 여기서 재료 손질을 미리 해뒀구나. 본 게임(SELECT)은 저 밑에 있겠네"** 라고 생각하시면 됩니다.

이해가 좀 되셨나요? 이제 이 `WITH`를 자유자재로 쓰시면 SQL 코딩 실력은 상위 20% 안에 든다고 보셔도 됩니다\! 👍