지금까지 정말 숨 가쁘게 달려오셨습니다\! 설치부터 시작해서 **테이블 생성, 데이터 입력, 조회, 조인, 그리고 서브쿼리**까지, 데이터 분석가가 실무에서 쓰는 핵심 기능의 80%를 이미 경험하셨습니다.

나중에 까먹었을 때 이 부분만 봐도 기억이 나도록 깔끔하게 요약해 드릴게요.

-----

### 1\. 뼈대 만들기 (DDL: 구조 정의)

엑셀 파일을 만들고 시트를 만드는 과정입니다.

  * **데이터베이스 생성:** `CREATE DATABASE 이름;` (폴더 만들기)
  * **사용 선언:** `USE 이름;` (폴더 더블클릭해서 들어가기)
  * **테이블 생성:** `CREATE TABLE 이름 ( ... );` (엑셀 시트 만들기)
      * `INT`: 숫자
      * `VARCHAR(n)`: 문자 (n글자까지)
      * `DATE`: 날짜
      * `PRIMARY KEY`: 고유 번호 (주민번호 같은 것)
      * `AUTO_INCREMENT`: 번호 자동 증가

### 2\. 데이터 다루기 (DML: 데이터 조작)

만들어진 시트에 값을 채우거나 고치는 과정입니다.

  * **입력:** `INSERT INTO 테이블 (컬럼1, 컬럼2) VALUES (값1, 값2);`
  * **수정:** `UPDATE 테이블 SET 컬럼 = 변경할값 WHERE 조건;` (조건 없으면 다 바뀜 주의\!)
  * **삭제:** `DELETE FROM 테이블 WHERE 조건;` (조건 없으면 다 지워짐 주의\!)

-----

### 3\. 데이터 분석하기 (DQL: 데이터 조회) **★가장 중요★**

현업에서 제일 많이 쓰는 "데이터 뽑아주세요" 명령어들입니다.

#### 기본 조회

  * **가져오기:** `SELECT 컬럼명`
  * **어디서:** `FROM 테이블명`
  * **조건필터:** `WHERE 조건` (예: `age >= 20`)

#### 집계와 그룹화 (피벗 테이블)

  * **그룹짓기:** `GROUP BY 컬럼명` (이 컬럼을 기준으로 뭉쳐라)
  * **계산함수:**
      * `COUNT(*)`: 개수 세기
      * `SUM(컬럼)`: 합계 구하기
      * `AVG(컬럼)`: 평균 구하기
      * `MAX(컬럼)` / `MIN(컬럼)`: 최대/최소값

#### 테이블 합치기 (VLOOKUP)

  * **조인:** `JOIN 붙일테이블 ON 기준테이블.키 = 붙일테이블.키`
      * 예: `JOIN member m ON o.member_id = m.id` (주문표의 회원ID와 회원표의 ID가 같은 것끼리 붙여라)

-----

### 4\. 고급 분석 기술 (프로의 영역)

단순 조회를 넘어, 데이터를 가공하고 비즈니스 인사이트를 만드는 기술입니다.

#### 조건별 분류 (IF문)

데이터를 내가 원하는 등급이나 이름으로 바꿀 때 씁니다.

```sql
CASE
    WHEN 조건1 THEN '결과1'
    WHEN 조건2 THEN '결과2'
    ELSE '나머지'
END
```

#### 서브쿼리 (쿼리 속의 쿼리)

복잡한 계산 결과를 **마치 새로운 테이블인 것처럼** 재사용할 때 씁니다.

```sql
SELECT ...
FROM (
    SELECT ... FROM ...  -- [안쪽 쿼리] 1차 가공
) AS 별명                -- [중요] 반드시 별명(Alias)을 붙여야 함!
```

-----

### 💡 한 눈에 보는 "마스터 쿼리"

이 코드 하나에 우리가 배운 모든 문법이 녹아있습니다. 복사해서 저장해두세요\!

```sql
SELECT
    -- 4. 최종적으로 보여줄 컬럼 선택 및 가공 (CASE WHEN)
    이름,
    구매횟수,
    CASE
        WHEN 총금액 > 100000 THEN 'VIP'
        ELSE '일반'
    END AS 등급
FROM
    (
        -- 1. [서브쿼리] 데이터를 먼저 요약 (GROUP BY & 함수)
        SELECT
            m.name AS 이름,
            COUNT(o.id) AS 구매횟수,
            SUM(o.amount) AS 총금액
        -- 2. [JOIN] 흩어진 데이터를 합치기
        FROM orders o
        JOIN member m ON o.member_id = m.id
        -- 3. [WHERE] 필요한 데이터만 1차 필터링 (예: 2024년 데이터만)
        WHERE o.order_date >= '2024-01-01'
        GROUP BY m.name
    ) AS summary_table; -- 서브쿼리 별명 필수
```

이제 기초 문법은 완벽하게 떼셨습니다. 이 문법들을 조합하면 현업의 웬만한 데이터 요청은 다 처리할 수 있습니다.

**다음 단계로는 무엇을 하고 싶으신가요?**

1.  **"이탈 고객(CHURN) 데이터만 엑셀로 뽑기"** (실무에서 제일 많이 하는 '데이터 추출' 마무리)
2.  **"날짜 다루기 심화"** (매출 분석할 때 필수인 '월별/요일별 매출' 뽑기)
3.  **"SQL 문제 풀이"** (코딩 테스트 준비를 위해 해커랭크 같은 사이트 문제 풀어보기)

원하시는 방향을 말씀해 주시면 맞춰서 가이드해 드릴게요\!

오늘 학습하시면서 헷갈려하셨던 핵심 포인트와 에러 해결법을 **Markdown(MD)** 파일 형식으로 깔끔하게 정리해 드립니다.

복습하실 때 이 내용만 훑어보셔도 큰 도움이 될 거예요\!

-----

# 📌 SQL 초보 탈출: 헷갈리는 문법 & 에러 노트

## 1\. 쿼리 시작 전 필수 체크 (`USE`)

**에러 코드:** `Error Code: 1046. No database selected`

  * **상황:** 코드를 실행했는데 "어느 폴더(DB)를 쓸 건지 말을 안 해줬어\!"라고 컴퓨터가 멈춤.
  * **해결:** 무조건 쿼리 **맨 첫 줄**에 아래 코드를 박아두고 시작할 것.

<!-- end list -->

```sql
USE shop; -- 데이터베이스 이름
```

-----

## 2\. FROM과 JOIN의 관계

**궁금증:** "왜 `FROM users`를 안 썼는데 `u.nickname`을 쓸 수 있나요?"

  * **핵심:** `JOIN`은 `FROM`의 친구입니다. `JOIN`으로 붙이는 순간 이미 가져온 것과 같습니다.
  * **문법 공식:**
    ```sql
    FROM payments p          -- 1. 메인 테이블 가져오고 (이름: p)
    JOIN users u             -- 2. 서브 테이블 붙이고 (이름: u)
    ON p.user_id = u.user_id -- 3. 연결 고리 확인 (Key 매칭)
    ```
    👉 **결론:** 위 3줄이 실행되면 `p`와 `u` 모두 내 마음대로 꺼내 쓸 수 있다.

-----

## 3\. GROUP BY 필수 규칙

**에러 코드:** `Error Code: 1140 ... incompatible with sql_mode=only_full_group_by`

  * **상황:** 집계 함수(`SUM`, `MAX`, `COUNT`)를 썼는데, 기준이 되는 컬럼을 그룹으로 안 묶었을 때 발생.

  * **해결 공식:** `SELECT`에 있는 컬럼 중 **계산 함수가 안 씌워진 애들**은 무조건 `GROUP BY`에 적어야 한다.

    ```sql
    SELECT 
        nickname,       -- (A) 계산 안 함 (그냥 출력)
        SUM(amount)     -- (B) 계산 함
    FROM ...
    GROUP BY nickname;  -- (A)는 반드시 여기에 적어줘야 함!
    ```

-----

## 4\. 세미콜론(`;`)의 위치

**에러 상황:** `JOIN` 뒤에 `;`를 찍어서 `GROUP BY`가 실행 안 됨.

  * **핵심:** 세미콜론은 \*\*"문장의 마침표"\*\*다. 문장이 다 끝나기 전에는 찍지 말자.
      * ❌ `JOIN users u;` (여기서 끊으면 뒤에 GROUP BY는 낙동강 오리알)
      * ⭕ `GROUP BY u.nickname;` (진짜 맨 마지막에 쾅\!)

-----

## 5\. 코딩 순서 (작성 vs 실행)

SQL은 읽는 순서와 쓰는 순서가 정반대입니다. **안에서 밖으로(Inside-Out)** 작성하세요.

1.  **FROM / JOIN**: 재료(테이블) 찾기
2.  **WHERE / GROUP BY**: 재료 다듬기 (필터링, 뭉치기)
3.  **SELECT**: 접시에 담기 (컬럼 선택)
4.  **ORDER BY**: 예쁘게 플레이팅 (정렬) - *오늘 안 썼지만 참고\!*

-----

## 6\. 서브쿼리(Subquery) 작성법

**문법:** 쿼리 결과를 **가상의 테이블**처럼 만들어서 재사용할 때.

  * **필수:** 괄호 `()`로 감싸고, 반드시 뒤에 \*\*별명(`AS 이름`)\*\*을 붙여야 한다.

    ```sql
    FROM 
        (
            SELECT ...
        ) AS game_data;  -- <-- 이 별명이 없으면 에러(Error 1248) 남!
    ```

-----

## 💡 Tip: 전체 조회 vs 특정 조회

  * `SELECT *`: **"몽땅 다 보여줘."** (연습할 때 좋음)
  * `SELECT col1, col2`: **"이것만 딱 집어서 보여줘."** (실무에서 좋음, 속도 빠름)
  
네, 아주 좋은 질문입니다\! `Day5_SQL_Practice.ipynb` 파일에 복사해서 바로 실행해 볼 수 있도록 **단계별 예시 코드**를 준비했습니다.

이 코드를 실행하면서 \*\*"어느 시점에 데이터가 걸러지는지"\*\*를 느끼는 게 포인트입니다.

-----

### **1. `WHERE`만 쓰는 경우 (데이터 전처리)**

  * **상황:** "그룹이고 뭐고 다 필요 없고, 일단 **'전자제품'** 산 기록만 보여줘."
  * **특징:** 집계(SUM, COUNT) 하기 **전**에 원본 데이터에서 걸러냅니다.

<!-- end list -->

```python
# 1. WHERE 예시: '전자제품' 카테고리만 골라내기
sql_where = """
SELECT user_id, category, amount
FROM orders
WHERE category = '전자제품'
"""
print("--- [1] WHERE 결과 (전자제품만) ---")
print(pd.read_sql(sql_where, conn))
```

### **2. `GROUP BY`만 쓰는 경우 (단순 집계)**

  * **상황:** "고객(`user_id`)별로 총 얼마를 썼는지(`SUM`) 보고 싶어."
  * **특징:** 데이터를 사람별로 뭉쳐서 계산합니다.

<!-- end list -->

```python
# 2. GROUP BY 예시: 고객별 총 주문 금액
sql_groupby = """
SELECT user_id, SUM(amount) as total_spent
FROM orders
GROUP BY user_id
"""
print("\n--- [2] GROUP BY 결과 (고객별 합계) ---")
print(pd.read_sql(sql_groupby, conn))
```

### **3. `GROUP BY` + `HAVING` (미션 정답\! 🎯)**

  * **상황:** "고객별 합계를 구했는데, 그중에서 **총액이 5만 원 이상**인 큰손들만 남겨줘."
  * **특징:** `SUM(amount)` 값은 그룹화가 끝나야 알 수 있죠? 그래서 `WHERE`가 아니라 `HAVING`을 씁니다.

<!-- end list -->

```python
# 3. GROUP BY + HAVING 예시 (미션 정답)
sql_having = """
SELECT user_id, SUM(amount) as total_spent
FROM orders
GROUP BY user_id
HAVING SUM(amount) >= 50000
"""
print("\n--- [3] 미션 정답: 5만원 이상 구매 고객 ---")
print(pd.read_sql(sql_having, conn))
```

-----

### **💡 한눈에 보는 요약**

| 구분 | 영어 뜻 | 역할 | 시점 |
| :--- | :--- | :--- | :--- |
| **WHERE** | 어디에 있는? | **원본 데이터**를 거른다. | 묶기 전 (Before) |
| **GROUP BY**| \~에 의해 묶다 | 데이터를 **끼리끼리** 뭉친다. | 중간 (Process) |
| **HAVING** | \~를 가지고 있는 | **계산된 결과**를 거른다. | 묶은 후 (After) |

네, 정말 핵심을 꿰뚫는 질문입니다\! 이 두 가지 질문은 데이터 분석가 면접 단골 질문이기도 합니다.

아주 명쾌하게 정리해 드릴게요.

-----

### **1. WHERE vs HAVING: "검문소가 어디에 있는가?"**

둘 다 \*\*"조건을 걸어 데이터를 거르는 역할"\*\*을 하지만, \*\*거르는 시점(Timing)\*\*이 완전히 다릅니다.

  * **`WHERE` (1차 검문소 - 입장 컷)**

      * **시점:** 그룹으로 묶기 **전(Before)**.
      * **대상:** 원본 데이터 한 줄 한 줄(Row)을 검사합니다.
      * **예시:** "전자제품인 주문만 들어와\!", "2024년 데이터만 들어와\!"
      * **특징:** 아직 그룹이 안 만들어졌기 때문에 `SUM()`, `COUNT()` 같은 집계 함수를 **절대 쓸 수 없습니다.**

  * **`HAVING` (2차 검문소 - 결산 컷)**

      * **시점:** 그룹으로 묶고 계산을 마친 **후(After)**.
      * **대상:** 요약된 그룹 결과(Group)를 검사합니다.
      * **예시:** "다 합쳐서(SUM) 5만 원 넘는 팀만 남와\!", "평균 점수(AVG) 80점 이상인 반만 남아\!"
      * **특징:** `GROUP BY`가 없으면 거의 쓰지 않으며, **반드시 집계 함수와 함께** 놉니다.

> **한 줄 요약:**
>
>   * **원시 데이터**를 거를 땐 👉 `WHERE`
>   * \*\*계산된 결과(집계)\*\*를 거를 땐 👉 `HAVING`

-----

### **2. SQL `GROUP BY` vs 파이썬 `groupby()`**

네, **100% 같은 개념**으로 보셔도 됩니다\!
데이터 분석의 대원칙인 **"Split-Apply-Combine (나누고-적용하고-합치기)"** 전략을 사용합니다.

다만, **사용하는 문법 스타일**만 살짝 다릅니다. 비교해서 보여드릴게요.

#### **상황: "user\_id 별로 amount 합계를 구하라"**

**[SQL]**

  * SQL은 문장 안에서 "묶어라(`GROUP BY`)"라고 시키고, 윗줄(`SELECT`)에서 바로 계산 결과를 보여줍니다.

<!-- end list -->

```sql
SELECT user_id, SUM(amount)
FROM orders
GROUP BY user_id;
```

**[Python Pandas]**

  * 판다스는 일단 묶어둔 \*\*객체(덩어리)\*\*를 먼저 만들고, 그 뒤에 계산 메서드(`.sum()`)를 붙입니다.

<!-- end list -->

```python
# df가 데이터프레임이라고 할 때
df.groupby('user_id')['amount'].sum()
```

**차이점:**

  * **SQL:** 결과표를 바로 뱉어냅니다.
  * **Python:** `groupby()`만 하면 결과를 안 보여주고 `<pandas...Groupby object>`라는 껍데기만 나옵니다. 뒤에 반드시 `.sum()`, `.mean()` 등을 붙여야 결과를 보여줍니다.

-----

### **🎓 Day 5 졸업 시험 (마지막)**

개념이 정리되셨다면, 이 쿼리의 **실행 순서**를 맞춰보세요. (마음속으로 순서를 매겨보세요.)

```sql
SELECT user_id, SUM(amount)      -- (4) 보여준다
FROM orders                      -- (1) 가져온다
WHERE category = '의류'          -- (2) 1차로 거른다 (누구만?)
GROUP BY user_id                 -- (3) 묶는다
HAVING SUM(amount) >= 30000;     -- (4) 2차로 거른다 (계산 후)
```

**정답 순서:**
**FROM** (테이블 가져오기) ➡️ **WHERE** (의류만 남기기) ➡️ **GROUP BY** (고객별로 묶기) ➡️ **HAVING** (합계 3만 원 이상만 남기기) ➡️ **SELECT** (최종 결과 출력)

이 순서가 머릿속에 그려지신다면, 오늘 **GROUP BY**는 완벽하게 마스터하신 겁니다\!

어떠신가요? 5일차 내용을 마무리하고 내일 6일차로 넘어가도 될까요?